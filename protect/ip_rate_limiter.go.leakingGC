package protect

import (
	"fmt"
	"net"
	"net/http"
	"strings"
	"sync"
	"time"
)

//
// ────────────────────────────────────────────────────────────
//  IP EXTRACTOR
// ────────────────────────────────────────────────────────────
//

// GetIP extracts a stable IP and avoids trusting X-Forwarded-For.
func GetIP(r *http.Request) string {
	hostPort := r.RemoteAddr
	if hostPort == "" {
		return ""
	}
	host, _, err := net.SplitHostPort(hostPort)
	if err != nil {
		return strings.Trim(hostPort, "[]")
	}
	return host
}

//
// ────────────────────────────────────────────────────────────
//  RATE LIMITER INTERNAL STRUCTS
// ────────────────────────────────────────────────────────────
//

type IPRateLimiter struct {
	mu          sync.Mutex
	entries     map[string]*ipEntry
	maxRequests int
	window      time.Duration
	staleAfter  time.Duration
}

type ipEntry struct {
	count       int
	windowStart time.Time
	lastSeen    time.Time
}

//
// ────────────────────────────────────────────────────────────
//  BUILDER
// ────────────────────────────────────────────────────────────
//

const (
	defaultMaxRequests = 10
	defaultWindow      = time.Second
)

// RateLimiterBuilder builds a configured RateLimiter.
type IPRateLimiterBuilder struct {
	maxRequests *int
	window      *time.Duration
}

// NewIPRateLimiter creates a fresh builder.
func NewIPRateLimiter() *IPRateLimiterBuilder {
	return &IPRateLimiterBuilder{}
}

// WithDefaults sets default values (optional).
func (b *IPRateLimiterBuilder) WithDefaults() *IPRateLimiterBuilder {
	if b.maxRequests == nil {
		v := defaultMaxRequests
		b.maxRequests = &v
	}
	if b.window == nil {
		v := defaultWindow
		b.window = &v
	}
	return b
}

// MaxRequests overrides max requests.
func (b *IPRateLimiterBuilder) MaxRequests(n int) *IPRateLimiterBuilder {
	b.maxRequests = &n
	return b
}

// Window overrides the window duration.
func (b *IPRateLimiterBuilder) Window(d time.Duration) *IPRateLimiterBuilder {
	b.window = &d
	return b
}

// Build performs validation + returns the RateLimiter.
func (b *IPRateLimiterBuilder) Build() *IPRateLimiter {

	// Apply defaults if not set.
	if b.maxRequests == nil {
		v := defaultMaxRequests
		b.maxRequests = &v
	}
	if b.window == nil {
		v := defaultWindow
		b.window = &v
	}

	// Validation
	if *b.maxRequests <= 0 {
		panic("protect: maxRequests must be > 0")
	}
	if *b.window <= 0 {
		panic("protect: window duration must be > 0")
	}

	return &IPRateLimiter{
		entries:     make(map[string]*ipEntry),
		maxRequests: *b.maxRequests,
		window:      *b.window,
		staleAfter:  (*b.window) * 2,
	}

}

//
// ────────────────────────────────────────────────────────────
//  RATE LIMITER LOGIC (same as your old code)
// ────────────────────────────────────────────────────────────
//

// Allow checks and updates rate limits.
func (rl *IPRateLimiter) Allow(key string) bool {
	now := time.Now()

	rl.mu.Lock()
	defer rl.mu.Unlock()

	// Quick GC for small servers/tests: run when map grows a bit.
	// This keeps entries from persisting for many windows in test runs.
	if len(rl.entries) > 100 {
		for k, e := range rl.entries {
			if now.Sub(e.lastSeen) > rl.staleAfter {
				delete(rl.entries, k)
			}
		}
	}

	e, ok := rl.entries[key]
	if !ok {
		// new entry, first request in window
		rl.entries[key] = &ipEntry{
			count:       1,
			windowStart: now,
			lastSeen:    now,
		}
		return true
	}

	// if window expired, reset the window *and* count
	if now.Sub(e.windowStart) >= rl.window {
		e.windowStart = now
		e.count = 1
		e.lastSeen = now
		return true
	}

	// within the same window: block when we've already reached maxRequests
	// use >= to avoid off-by-one
	if e.count >= rl.maxRequests {
		e.lastSeen = now
		return false
	}

	// allow and increment
	e.count++
	e.lastSeen = now
	fmt.Printf("ALLOW ip=%s count=%d start=%s now=%s max=%d\n", key, e.count, e.windowStart.Format(time.RFC3339Nano), now.Format(time.RFC3339Nano), rl.maxRequests)

	return true
}

// Inspect returns current state (debug only).
func (rl *IPRateLimiter) Inspect(key string) (count int, start time.Time, found bool) {
	rl.mu.Lock()
	defer rl.mu.Unlock()

	e, ok := rl.entries[key]
	if !ok {
		return 0, time.Time{}, false
	}
	return e.count, e.windowStart, true
}
